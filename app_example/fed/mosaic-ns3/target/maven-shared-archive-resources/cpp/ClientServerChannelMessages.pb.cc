// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ClientServerChannelMessages.proto

#include "ClientServerChannelMessages.pb.h"

#include <algorithm>
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/extension_set.h"
#include "google/protobuf/wire_format_lite.h"
#include "google/protobuf/descriptor.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/reflection_ops.h"
#include "google/protobuf/wire_format.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"
PROTOBUF_PRAGMA_INIT_SEG
namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = ::PROTOBUF_NAMESPACE_ID::internal;
namespace ClientServerChannelSpace {
template <typename>
PROTOBUF_CONSTEXPR CommandMessage::CommandMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.command_type_)*/ -1
} {}
struct CommandMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CommandMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~CommandMessageDefaultTypeInternal() {}
  union {
    CommandMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CommandMessageDefaultTypeInternal _CommandMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdateNode_NodeData::UpdateNode_NodeData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.x_)*/ 0

  , /*decltype(_impl_.y_)*/ 0

  , /*decltype(_impl_.id_)*/ 0
} {}
struct UpdateNode_NodeDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNode_NodeDataDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNode_NodeDataDefaultTypeInternal() {}
  union {
    UpdateNode_NodeData _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNode_NodeDataDefaultTypeInternal _UpdateNode_NodeData_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR UpdateNode::UpdateNode(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.properties_)*/{}
  , /*decltype(_impl_.time_)*/ ::int64_t{0}

  , /*decltype(_impl_.update_type_)*/ 1
} {}
struct UpdateNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR UpdateNodeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~UpdateNodeDefaultTypeInternal() {}
  union {
    UpdateNode _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 UpdateNodeDefaultTypeInternal _UpdateNode_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR InitMessage::InitMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.start_time_)*/ ::int64_t{0}

  , /*decltype(_impl_.end_time_)*/ ::int64_t{0}
} {}
struct InitMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR InitMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~InitMessageDefaultTypeInternal() {}
  union {
    InitMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 InitMessageDefaultTypeInternal _InitMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR PortExchange::PortExchange(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.port_number_)*/ 0u
} {}
struct PortExchangeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR PortExchangeDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~PortExchangeDefaultTypeInternal() {}
  union {
    PortExchange _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 PortExchangeDefaultTypeInternal _PortExchange_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR TimeMessage::TimeMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/ ::int64_t{0}
} {}
struct TimeMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TimeMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~TimeMessageDefaultTypeInternal() {}
  union {
    TimeMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TimeMessageDefaultTypeInternal _TimeMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ReceiveMessage::ReceiveMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/ ::int64_t{0}

  , /*decltype(_impl_.node_id_)*/ 0u

  , /*decltype(_impl_.channel_id_)*/ 0

  , /*decltype(_impl_.message_id_)*/ 0u

  , /*decltype(_impl_.rssi_)*/ 0
} {}
struct ReceiveMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ReceiveMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ReceiveMessageDefaultTypeInternal() {}
  union {
    ReceiveMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ReceiveMessageDefaultTypeInternal _ReceiveMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ConfigureRadioMessage_RadioConfiguration::ConfigureRadioMessage_RadioConfiguration(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.receiving_messages_)*/ false

  , /*decltype(_impl_.ip_address_)*/ 0u

  , /*decltype(_impl_.transmission_power_)*/ 0

  , /*decltype(_impl_.subnet_address_)*/ 0u

  , /*decltype(_impl_.primary_radio_channel_)*/ 0

  , /*decltype(_impl_.secondary_radio_channel_)*/ 0

  , /*decltype(_impl_.radio_mode_)*/ 1
} {}
struct ConfigureRadioMessage_RadioConfigurationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigureRadioMessage_RadioConfigurationDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigureRadioMessage_RadioConfigurationDefaultTypeInternal() {}
  union {
    ConfigureRadioMessage_RadioConfiguration _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigureRadioMessage_RadioConfigurationDefaultTypeInternal _ConfigureRadioMessage_RadioConfiguration_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR ConfigureRadioMessage::ConfigureRadioMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.primary_radio_configuration_)*/nullptr
  , /*decltype(_impl_.secondary_radio_configuration_)*/nullptr
  , /*decltype(_impl_.time_)*/ ::int64_t{0}

  , /*decltype(_impl_.message_id_)*/ 0u

  , /*decltype(_impl_.external_id_)*/ 0u

  , /*decltype(_impl_.radio_number_)*/ 0
} {}
struct ConfigureRadioMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ConfigureRadioMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~ConfigureRadioMessageDefaultTypeInternal() {}
  union {
    ConfigureRadioMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ConfigureRadioMessageDefaultTypeInternal _ConfigureRadioMessage_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SendMessageMessage_TopoAddress::SendMessageMessage_TopoAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ip_address_)*/ 0u

  , /*decltype(_impl_.ttl_)*/ 0u
} {}
struct SendMessageMessage_TopoAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendMessageMessage_TopoAddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendMessageMessage_TopoAddressDefaultTypeInternal() {}
  union {
    SendMessageMessage_TopoAddress _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendMessageMessage_TopoAddressDefaultTypeInternal _SendMessageMessage_TopoAddress_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SendMessageMessage_GeoRectangleAddress::SendMessageMessage_GeoRectangleAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.a_x_)*/ 0

  , /*decltype(_impl_.a_y_)*/ 0

  , /*decltype(_impl_.b_x_)*/ 0

  , /*decltype(_impl_.b_y_)*/ 0

  , /*decltype(_impl_.ip_address_)*/ 0u
} {}
struct SendMessageMessage_GeoRectangleAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendMessageMessage_GeoRectangleAddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendMessageMessage_GeoRectangleAddressDefaultTypeInternal() {}
  union {
    SendMessageMessage_GeoRectangleAddress _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendMessageMessage_GeoRectangleAddressDefaultTypeInternal _SendMessageMessage_GeoRectangleAddress_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SendMessageMessage_GeoCircleAddress::SendMessageMessage_GeoCircleAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.center_x_)*/ 0

  , /*decltype(_impl_.center_y_)*/ 0

  , /*decltype(_impl_.radius_)*/ 0

  , /*decltype(_impl_.ip_address_)*/ 0u
} {}
struct SendMessageMessage_GeoCircleAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendMessageMessage_GeoCircleAddressDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendMessageMessage_GeoCircleAddressDefaultTypeInternal() {}
  union {
    SendMessageMessage_GeoCircleAddress _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendMessageMessage_GeoCircleAddressDefaultTypeInternal _SendMessageMessage_GeoCircleAddress_default_instance_;
template <typename>
PROTOBUF_CONSTEXPR SendMessageMessage::SendMessageMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.time_)*/ ::int64_t{0}

  , /*decltype(_impl_.node_id_)*/ 0u

  , /*decltype(_impl_.channel_id_)*/ 0

  , /*decltype(_impl_.length_)*/ ::uint64_t{0u}

  , /*decltype(_impl_.message_id_)*/ 0u

  , /*decltype(_impl_.address_)*/{}
  , /*decltype(_impl_._oneof_case_)*/{}} {}
struct SendMessageMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SendMessageMessageDefaultTypeInternal() : _instance(::_pbi::ConstantInitialized{}) {}
  ~SendMessageMessageDefaultTypeInternal() {}
  union {
    SendMessageMessage _instance;
  };
};

PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT
    PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SendMessageMessageDefaultTypeInternal _SendMessageMessage_default_instance_;
}  // namespace ClientServerChannelSpace
static ::_pb::Metadata file_level_metadata_ClientServerChannelMessages_2eproto[13];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_ClientServerChannelMessages_2eproto[5];
static constexpr const ::_pb::ServiceDescriptor**
    file_level_service_descriptors_ClientServerChannelMessages_2eproto = nullptr;
const ::uint32_t TableStruct_ClientServerChannelMessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(
    protodesc_cold) = {
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::CommandMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::CommandMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::CommandMessage, _impl_.command_type_),
    0,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode_NodeData, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode_NodeData, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode_NodeData, _impl_.id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode_NodeData, _impl_.x_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode_NodeData, _impl_.y_),
    2,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode, _impl_.update_type_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode, _impl_.time_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::UpdateNode, _impl_.properties_),
    1,
    0,
    ~0u,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::InitMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::InitMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::InitMessage, _impl_.start_time_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::InitMessage, _impl_.end_time_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::PortExchange, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::PortExchange, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::PortExchange, _impl_.port_number_),
    0,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::TimeMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::TimeMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::TimeMessage, _impl_.time_),
    0,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _impl_.time_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _impl_.node_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _impl_.channel_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _impl_.message_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ReceiveMessage, _impl_.rssi_),
    0,
    1,
    2,
    3,
    4,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.receiving_messages_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.ip_address_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.subnet_address_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.transmission_power_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.radio_mode_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.primary_radio_channel_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration, _impl_.secondary_radio_channel_),
    0,
    1,
    3,
    2,
    6,
    4,
    5,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_.time_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_.message_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_.external_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_.radio_number_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_.primary_radio_configuration_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::ConfigureRadioMessage, _impl_.secondary_radio_configuration_),
    2,
    3,
    4,
    5,
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_TopoAddress, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_TopoAddress, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_TopoAddress, _impl_.ip_address_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_TopoAddress, _impl_.ttl_),
    0,
    1,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _impl_.ip_address_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _impl_.a_x_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _impl_.a_y_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _impl_.b_x_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress, _impl_.b_y_),
    4,
    0,
    1,
    2,
    3,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress, _internal_metadata_),
    ~0u,  // no _extensions_
    ~0u,  // no _oneof_case_
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress, _impl_.ip_address_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress, _impl_.center_x_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress, _impl_.center_y_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress, _impl_.radius_),
    3,
    0,
    1,
    2,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_._has_bits_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _internal_metadata_),
    ~0u,  // no _extensions_
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_._oneof_case_[0]),
    ~0u,  // no _weak_field_map_
    ~0u,  // no _inlined_string_donated_
    ~0u,  // no _split_
    ~0u,  // no sizeof(Split)
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_.time_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_.node_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_.channel_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_.message_id_),
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_.length_),
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    ::_pbi::kInvalidFieldOffsetTag,
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_.address_),
    0,
    1,
    2,
    4,
    3,
    ~0u,
    ~0u,
    ~0u,
};

static const ::_pbi::MigrationSchema
    schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
        { 0, 9, -1, sizeof(::ClientServerChannelSpace::CommandMessage)},
        { 10, 21, -1, sizeof(::ClientServerChannelSpace::UpdateNode_NodeData)},
        { 24, 35, -1, sizeof(::ClientServerChannelSpace::UpdateNode)},
        { 38, 48, -1, sizeof(::ClientServerChannelSpace::InitMessage)},
        { 50, 59, -1, sizeof(::ClientServerChannelSpace::PortExchange)},
        { 60, 69, -1, sizeof(::ClientServerChannelSpace::TimeMessage)},
        { 70, 83, -1, sizeof(::ClientServerChannelSpace::ReceiveMessage)},
        { 88, 103, -1, sizeof(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration)},
        { 110, 124, -1, sizeof(::ClientServerChannelSpace::ConfigureRadioMessage)},
        { 130, 140, -1, sizeof(::ClientServerChannelSpace::SendMessageMessage_TopoAddress)},
        { 142, 155, -1, sizeof(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress)},
        { 160, 172, -1, sizeof(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress)},
        { 176, 193, -1, sizeof(::ClientServerChannelSpace::SendMessageMessage)},
};

static const ::_pb::Message* const file_default_instances[] = {
    &::ClientServerChannelSpace::_CommandMessage_default_instance_._instance,
    &::ClientServerChannelSpace::_UpdateNode_NodeData_default_instance_._instance,
    &::ClientServerChannelSpace::_UpdateNode_default_instance_._instance,
    &::ClientServerChannelSpace::_InitMessage_default_instance_._instance,
    &::ClientServerChannelSpace::_PortExchange_default_instance_._instance,
    &::ClientServerChannelSpace::_TimeMessage_default_instance_._instance,
    &::ClientServerChannelSpace::_ReceiveMessage_default_instance_._instance,
    &::ClientServerChannelSpace::_ConfigureRadioMessage_RadioConfiguration_default_instance_._instance,
    &::ClientServerChannelSpace::_ConfigureRadioMessage_default_instance_._instance,
    &::ClientServerChannelSpace::_SendMessageMessage_TopoAddress_default_instance_._instance,
    &::ClientServerChannelSpace::_SendMessageMessage_GeoRectangleAddress_default_instance_._instance,
    &::ClientServerChannelSpace::_SendMessageMessage_GeoCircleAddress_default_instance_._instance,
    &::ClientServerChannelSpace::_SendMessageMessage_default_instance_._instance,
};
const char descriptor_table_protodef_ClientServerChannelMessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
    "\n!ClientServerChannelMessages.proto\022\030Cli"
    "entServerChannelSpace\"\237\002\n\016CommandMessage"
    "\022J\n\014command_type\030\001 \002(\01624.ClientServerCha"
    "nnelSpace.CommandMessage.CommandType\"\300\001\n"
    "\013CommandType\022\022\n\005UNDEF\020\377\377\377\377\377\377\377\377\377\001\022\010\n\004INIT"
    "\020\001\022\r\n\tSHUT_DOWN\020\002\022\017\n\013UPDATE_NODE\020\n\022\017\n\013RE"
    "MOVE_NODE\020\013\022\020\n\014ADVANCE_TIME\020\024\022\016\n\nNEXT_EV"
    "ENT\020\025\022\014\n\010MSG_RECV\020\026\022\014\n\010MSG_SEND\020\036\022\016\n\nCON"
    "F_RADIO\020\037\022\007\n\003END\020(\022\013\n\007SUCCESS\020)\"\235\002\n\nUpda"
    "teNode\022D\n\013update_type\030\001 \002(\0162/.ClientServ"
    "erChannelSpace.UpdateNode.UpdateType\022\014\n\004"
    "time\030\002 \002(\003\022A\n\nproperties\030\003 \003(\0132-.ClientS"
    "erverChannelSpace.UpdateNode.NodeData\032,\n"
    "\010NodeData\022\n\n\002id\030\001 \002(\005\022\t\n\001x\030\002 \002(\001\022\t\n\001y\030\003 "
    "\002(\001\"J\n\nUpdateType\022\013\n\007ADD_RSU\020\001\022\017\n\013ADD_VE"
    "HICLE\020\002\022\r\n\tMOVE_NODE\020\003\022\017\n\013REMOVE_NODE\020\004\""
    "3\n\013InitMessage\022\022\n\nstart_time\030\001 \002(\003\022\020\n\010en"
    "d_time\030\002 \002(\003\"#\n\014PortExchange\022\023\n\013port_num"
    "ber\030\001 \002(\r\"\033\n\013TimeMessage\022\014\n\004time\030\001 \002(\003\"\215"
    "\001\n\016ReceiveMessage\022\014\n\004time\030\001 \002(\003\022\017\n\007node_"
    "id\030\002 \002(\r\022:\n\nchannel_id\030\003 \002(\0162&.ClientSer"
    "verChannelSpace.RadioChannel\022\022\n\nmessage_"
    "id\030\004 \002(\r\022\014\n\004rssi\030\005 \002(\002\"\324\006\n\025ConfigureRadi"
    "oMessage\022\014\n\004time\030\001 \002(\003\022\022\n\nmessage_id\030\002 \002"
    "(\r\022\023\n\013external_id\030\003 \002(\r\022Q\n\014radio_number\030"
    "\004 \002(\0162;.ClientServerChannelSpace.Configu"
    "reRadioMessage.RadioNumber\022g\n\033primary_ra"
    "dio_configuration\030\005 \002(\0132B.ClientServerCh"
    "annelSpace.ConfigureRadioMessage.RadioCo"
    "nfiguration\022i\n\035secondary_radio_configura"
    "tion\030\006 \001(\0132B.ClientServerChannelSpace.Co"
    "nfigureRadioMessage.RadioConfiguration\032\235"
    "\003\n\022RadioConfiguration\022\032\n\022receiving_messa"
    "ges\030\001 \002(\010\022\022\n\nip_address\030\002 \002(\r\022\026\n\016subnet_"
    "address\030\003 \002(\r\022\032\n\022transmission_power\030\004 \002("
    "\001\022`\n\nradio_mode\030\005 \002(\0162L.ClientServerChan"
    "nelSpace.ConfigureRadioMessage.RadioConf"
    "iguration.RadioMode\022E\n\025primary_radio_cha"
    "nnel\030\006 \002(\0162&.ClientServerChannelSpace.Ra"
    "dioChannel\022G\n\027secondary_radio_channel\030\007 "
    "\001(\0162&.ClientServerChannelSpace.RadioChan"
    "nel\"1\n\tRadioMode\022\022\n\016SINGLE_CHANNEL\020\001\022\020\n\014"
    "DUAL_CHANNEL\020\002\"=\n\013RadioNumber\022\014\n\010NO_RADI"
    "O\020\000\022\020\n\014SINGLE_RADIO\020\001\022\016\n\nDUAL_RADIO\020\002\"\223\005"
    "\n\022SendMessageMessage\022\014\n\004time\030\001 \002(\003\022\017\n\007no"
    "de_id\030\002 \002(\r\022:\n\nchannel_id\030\003 \002(\0162&.Client"
    "ServerChannelSpace.RadioChannel\022\022\n\nmessa"
    "ge_id\030\004 \002(\r\022\016\n\006length\030\005 \002(\004\022P\n\014topo_addr"
    "ess\030\006 \001(\01328.ClientServerChannelSpace.Sen"
    "dMessageMessage.TopoAddressH\000\022]\n\021rectang"
    "le_address\030\007 \001(\0132@.ClientServerChannelSp"
    "ace.SendMessageMessage.GeoRectangleAddre"
    "ssH\000\022W\n\016circle_address\030\010 \001(\0132=.ClientSer"
    "verChannelSpace.SendMessageMessage.GeoCi"
    "rcleAddressH\000\032.\n\013TopoAddress\022\022\n\nip_addre"
    "ss\030\001 \002(\r\022\013\n\003ttl\030\002 \002(\r\032]\n\023GeoRectangleAdd"
    "ress\022\022\n\nip_address\030\001 \002(\r\022\013\n\003a_X\030\002 \002(\001\022\013\n"
    "\003a_Y\030\003 \002(\001\022\013\n\003b_X\030\004 \002(\001\022\013\n\003b_Y\030\005 \002(\001\032Z\n\020"
    "GeoCircleAddress\022\022\n\nip_address\030\001 \002(\r\022\020\n\010"
    "center_X\030\002 \002(\001\022\020\n\010center_Y\030\003 \002(\001\022\016\n\006radi"
    "us\030\004 \002(\001B\t\n\007address*\216\001\n\014RadioChannel\022\016\n\n"
    "PROTO_SCH1\020\000\022\016\n\nPROTO_SCH2\020\001\022\016\n\nPROTO_SC"
    "H3\020\002\022\r\n\tPROTO_CCH\020\003\022\016\n\nPROTO_SCH4\020\004\022\016\n\nP"
    "ROTO_SCH5\020\005\022\016\n\nPROTO_SCH6\020\006\022\017\n\013PROTO_UND"
    "EF\020\007B<\n\037org.eclipse.mosaic.lib.couplingB"
    "\031ClientServerChannelProtos"
};
static ::absl::once_flag descriptor_table_ClientServerChannelMessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_ClientServerChannelMessages_2eproto = {
    false,
    false,
    2626,
    descriptor_table_protodef_ClientServerChannelMessages_2eproto,
    "ClientServerChannelMessages.proto",
    &descriptor_table_ClientServerChannelMessages_2eproto_once,
    nullptr,
    0,
    13,
    schemas,
    file_default_instances,
    TableStruct_ClientServerChannelMessages_2eproto::offsets,
    file_level_metadata_ClientServerChannelMessages_2eproto,
    file_level_enum_descriptors_ClientServerChannelMessages_2eproto,
    file_level_service_descriptors_ClientServerChannelMessages_2eproto,
};

// This function exists to be marked as weak.
// It can significantly speed up compilation by breaking up LLVM's SCC
// in the .pb.cc translation units. Large translation units see a
// reduction of more than 35% of walltime for optimized builds. Without
// the weak attribute all the messages in the file, including all the
// vtables and everything they use become part of the same SCC through
// a cycle like:
// GetMetadata -> descriptor table -> default instances ->
//   vtables -> GetMetadata
// By adding a weak function here we break the connection from the
// individual vtables back into the descriptor table.
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_ClientServerChannelMessages_2eproto_getter() {
  return &descriptor_table_ClientServerChannelMessages_2eproto;
}
// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2
static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_ClientServerChannelMessages_2eproto(&descriptor_table_ClientServerChannelMessages_2eproto);
namespace ClientServerChannelSpace {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CommandMessage_CommandType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ClientServerChannelMessages_2eproto);
  return file_level_enum_descriptors_ClientServerChannelMessages_2eproto[0];
}
bool CommandMessage_CommandType_IsValid(int value) {
  switch (value) {
    case -1:
    case 1:
    case 2:
    case 10:
    case 11:
    case 20:
    case 21:
    case 22:
    case 30:
    case 31:
    case 40:
    case 41:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr CommandMessage_CommandType CommandMessage::UNDEF;
constexpr CommandMessage_CommandType CommandMessage::INIT;
constexpr CommandMessage_CommandType CommandMessage::SHUT_DOWN;
constexpr CommandMessage_CommandType CommandMessage::UPDATE_NODE;
constexpr CommandMessage_CommandType CommandMessage::REMOVE_NODE;
constexpr CommandMessage_CommandType CommandMessage::ADVANCE_TIME;
constexpr CommandMessage_CommandType CommandMessage::NEXT_EVENT;
constexpr CommandMessage_CommandType CommandMessage::MSG_RECV;
constexpr CommandMessage_CommandType CommandMessage::MSG_SEND;
constexpr CommandMessage_CommandType CommandMessage::CONF_RADIO;
constexpr CommandMessage_CommandType CommandMessage::END;
constexpr CommandMessage_CommandType CommandMessage::SUCCESS;
constexpr CommandMessage_CommandType CommandMessage::CommandType_MIN;
constexpr CommandMessage_CommandType CommandMessage::CommandType_MAX;
constexpr int CommandMessage::CommandType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* UpdateNode_UpdateType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ClientServerChannelMessages_2eproto);
  return file_level_enum_descriptors_ClientServerChannelMessages_2eproto[1];
}
bool UpdateNode_UpdateType_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr UpdateNode_UpdateType UpdateNode::ADD_RSU;
constexpr UpdateNode_UpdateType UpdateNode::ADD_VEHICLE;
constexpr UpdateNode_UpdateType UpdateNode::MOVE_NODE;
constexpr UpdateNode_UpdateType UpdateNode::REMOVE_NODE;
constexpr UpdateNode_UpdateType UpdateNode::UpdateType_MIN;
constexpr UpdateNode_UpdateType UpdateNode::UpdateType_MAX;
constexpr int UpdateNode::UpdateType_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfigureRadioMessage_RadioConfiguration_RadioMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ClientServerChannelMessages_2eproto);
  return file_level_enum_descriptors_ClientServerChannelMessages_2eproto[2];
}
bool ConfigureRadioMessage_RadioConfiguration_RadioMode_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ConfigureRadioMessage_RadioConfiguration_RadioMode ConfigureRadioMessage_RadioConfiguration::SINGLE_CHANNEL;
constexpr ConfigureRadioMessage_RadioConfiguration_RadioMode ConfigureRadioMessage_RadioConfiguration::DUAL_CHANNEL;
constexpr ConfigureRadioMessage_RadioConfiguration_RadioMode ConfigureRadioMessage_RadioConfiguration::RadioMode_MIN;
constexpr ConfigureRadioMessage_RadioConfiguration_RadioMode ConfigureRadioMessage_RadioConfiguration::RadioMode_MAX;
constexpr int ConfigureRadioMessage_RadioConfiguration::RadioMode_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ConfigureRadioMessage_RadioNumber_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ClientServerChannelMessages_2eproto);
  return file_level_enum_descriptors_ClientServerChannelMessages_2eproto[3];
}
bool ConfigureRadioMessage_RadioNumber_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}
#if (__cplusplus < 201703) && \
  (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

constexpr ConfigureRadioMessage_RadioNumber ConfigureRadioMessage::NO_RADIO;
constexpr ConfigureRadioMessage_RadioNumber ConfigureRadioMessage::SINGLE_RADIO;
constexpr ConfigureRadioMessage_RadioNumber ConfigureRadioMessage::DUAL_RADIO;
constexpr ConfigureRadioMessage_RadioNumber ConfigureRadioMessage::RadioNumber_MIN;
constexpr ConfigureRadioMessage_RadioNumber ConfigureRadioMessage::RadioNumber_MAX;
constexpr int ConfigureRadioMessage::RadioNumber_ARRAYSIZE;

#endif  // (__cplusplus < 201703) &&
        // (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RadioChannel_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_ClientServerChannelMessages_2eproto);
  return file_level_enum_descriptors_ClientServerChannelMessages_2eproto[4];
}
bool RadioChannel_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}
// ===================================================================

class CommandMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CommandMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(CommandMessage, _impl_._has_bits_);
  static void set_has_command_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

CommandMessage::CommandMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.CommandMessage)
}
CommandMessage::CommandMessage(const CommandMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.CommandMessage)
}

inline void CommandMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.command_type_) { -1 }

  };
}

CommandMessage::~CommandMessage() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.CommandMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CommandMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void CommandMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CommandMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.CommandMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.command_type_ = -1;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CommandMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ClientServerChannelSpace.CommandMessage.CommandType command_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::CommandMessage_CommandType_IsValid(static_cast<int>(val)))) {
            _internal_set_command_type(static_cast<::ClientServerChannelSpace::CommandMessage_CommandType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* CommandMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.CommandMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ClientServerChannelSpace.CommandMessage.CommandType command_type = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_command_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.CommandMessage)
  return target;
}

::size_t CommandMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.CommandMessage)
  ::size_t total_size = 0;

  // required .ClientServerChannelSpace.CommandMessage.CommandType command_type = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_command_type());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CommandMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CommandMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CommandMessage::GetClassData() const { return &_class_data_; }


void CommandMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CommandMessage*>(&to_msg);
  auto& from = static_cast<const CommandMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.CommandMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_command_type(from._internal_command_type());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CommandMessage::CopyFrom(const CommandMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.CommandMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void CommandMessage::InternalSwap(CommandMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.command_type_, other->_impl_.command_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CommandMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[0]);
}
// ===================================================================

class UpdateNode_NodeData::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateNode_NodeData>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UpdateNode_NodeData, _impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

UpdateNode_NodeData::UpdateNode_NodeData(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.UpdateNode.NodeData)
}
UpdateNode_NodeData::UpdateNode_NodeData(const UpdateNode_NodeData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.UpdateNode.NodeData)
}

inline void UpdateNode_NodeData::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.x_) { 0 }

    , decltype(_impl_.y_) { 0 }

    , decltype(_impl_.id_) { 0 }

  };
}

UpdateNode_NodeData::~UpdateNode_NodeData() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.UpdateNode.NodeData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNode_NodeData::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void UpdateNode_NodeData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNode_NodeData::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.UpdateNode.NodeData)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.x_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.id_) -
        reinterpret_cast<char*>(&_impl_.x_)) + sizeof(_impl_.id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNode_NodeData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double x = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_x(&has_bits);
          _impl_.x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_y(&has_bits);
          _impl_.y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdateNode_NodeData::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.UpdateNode.NodeData)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(
        1, this->_internal_id(), target);
  }

  // required double x = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_x(), target);
  }

  // required double y = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.UpdateNode.NodeData)
  return target;
}

::size_t UpdateNode_NodeData::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.UpdateNode.NodeData)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double x = 2;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double y = 3;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());
  }

  return total_size;
}
::size_t UpdateNode_NodeData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.UpdateNode.NodeData)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required double x = 2;
    total_size += 9;

    // required double y = 3;
    total_size += 9;

    // required int32 id = 1;
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(
        this->_internal_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNode_NodeData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNode_NodeData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNode_NodeData::GetClassData() const { return &_class_data_; }


void UpdateNode_NodeData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNode_NodeData*>(&to_msg);
  auto& from = static_cast<const UpdateNode_NodeData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.UpdateNode.NodeData)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.x_ = from._impl_.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.y_ = from._impl_.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNode_NodeData::CopyFrom(const UpdateNode_NodeData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.UpdateNode.NodeData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNode_NodeData::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void UpdateNode_NodeData::InternalSwap(UpdateNode_NodeData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNode_NodeData, _impl_.id_)
      + sizeof(UpdateNode_NodeData::_impl_.id_)
      - PROTOBUF_FIELD_OFFSET(UpdateNode_NodeData, _impl_.x_)>(
          reinterpret_cast<char*>(&_impl_.x_),
          reinterpret_cast<char*>(&other->_impl_.x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNode_NodeData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[1]);
}
// ===================================================================

class UpdateNode::_Internal {
 public:
  using HasBits = decltype(std::declval<UpdateNode>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(UpdateNode, _impl_._has_bits_);
  static void set_has_update_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

UpdateNode::UpdateNode(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.UpdateNode)
}
UpdateNode::UpdateNode(const UpdateNode& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  UpdateNode* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.properties_){from._impl_.properties_}
    , decltype(_impl_.time_) {}

    , decltype(_impl_.update_type_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.update_type_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.update_type_));
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.UpdateNode)
}

inline void UpdateNode::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.properties_){arena}
    , decltype(_impl_.time_) { ::int64_t{0} }

    , decltype(_impl_.update_type_) { 1 }

  };
}

UpdateNode::~UpdateNode() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.UpdateNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void UpdateNode::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  _internal_mutable_properties()->~RepeatedPtrField();
}

void UpdateNode::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void UpdateNode::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.UpdateNode)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _internal_mutable_properties()->Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.time_ = ::int64_t{0};
    _impl_.update_type_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* UpdateNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .ClientServerChannelSpace.UpdateNode.UpdateType update_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::UpdateNode_UpdateType_IsValid(static_cast<int>(val)))) {
            _internal_set_update_type(static_cast<::ClientServerChannelSpace::UpdateNode_UpdateType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // required int64 time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // repeated .ClientServerChannelSpace.UpdateNode.NodeData properties = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_properties(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* UpdateNode::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.UpdateNode)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .ClientServerChannelSpace.UpdateNode.UpdateType update_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        1, this->_internal_update_type(), target);
  }

  // required int64 time = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_time(), target);
  }

  // repeated .ClientServerChannelSpace.UpdateNode.NodeData properties = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_properties_size()); i < n; i++) {
    const auto& repfield = this->_internal_properties(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.UpdateNode)
  return target;
}

::size_t UpdateNode::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.UpdateNode)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required int64 time = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required .ClientServerChannelSpace.UpdateNode.UpdateType update_type = 1;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_update_type());
  }

  return total_size;
}
::size_t UpdateNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.UpdateNode)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 time = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());

    // required .ClientServerChannelSpace.UpdateNode.UpdateType update_type = 1;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_update_type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ClientServerChannelSpace.UpdateNode.NodeData properties = 3;
  total_size += 1UL * this->_internal_properties_size();
  for (const auto& msg : this->_internal_properties()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData UpdateNode::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    UpdateNode::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*UpdateNode::GetClassData() const { return &_class_data_; }


void UpdateNode::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<UpdateNode*>(&to_msg);
  auto& from = static_cast<const UpdateNode&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.UpdateNode)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_internal_mutable_properties()->MergeFrom(from._internal_properties());
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.update_type_ = from._impl_.update_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void UpdateNode::CopyFrom(const UpdateNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.UpdateNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UpdateNode::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_internal_properties()))
    return false;
  return true;
}

void UpdateNode::InternalSwap(UpdateNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _internal_mutable_properties()->InternalSwap(other->_internal_mutable_properties());
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(UpdateNode, _impl_.update_type_)
      + sizeof(UpdateNode::_impl_.update_type_)
      - PROTOBUF_FIELD_OFFSET(UpdateNode, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata UpdateNode::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[2]);
}
// ===================================================================

class InitMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<InitMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(InitMessage, _impl_._has_bits_);
  static void set_has_start_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_end_time(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

InitMessage::InitMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.InitMessage)
}
InitMessage::InitMessage(const InitMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.InitMessage)
}

inline void InitMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.start_time_) { ::int64_t{0} }

    , decltype(_impl_.end_time_) { ::int64_t{0} }

  };
}

InitMessage::~InitMessage() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.InitMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void InitMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void InitMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void InitMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.InitMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.start_time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.end_time_) -
        reinterpret_cast<char*>(&_impl_.start_time_)) + sizeof(_impl_.end_time_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* InitMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 start_time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_start_time(&has_bits);
          _impl_.start_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required int64 end_time = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_end_time(&has_bits);
          _impl_.end_time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* InitMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.InitMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 start_time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_start_time(), target);
  }

  // required int64 end_time = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        2, this->_internal_end_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.InitMessage)
  return target;
}

::size_t InitMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.InitMessage)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required int64 start_time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_start_time());
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required int64 end_time = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_end_time());
  }

  return total_size;
}
::size_t InitMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.InitMessage)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required int64 start_time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_start_time());

    // required int64 end_time = 2;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_end_time());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData InitMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    InitMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*InitMessage::GetClassData() const { return &_class_data_; }


void InitMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<InitMessage*>(&to_msg);
  auto& from = static_cast<const InitMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.InitMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.start_time_ = from._impl_.start_time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.end_time_ = from._impl_.end_time_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void InitMessage::CopyFrom(const InitMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.InitMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InitMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void InitMessage::InternalSwap(InitMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(InitMessage, _impl_.end_time_)
      + sizeof(InitMessage::_impl_.end_time_)
      - PROTOBUF_FIELD_OFFSET(InitMessage, _impl_.start_time_)>(
          reinterpret_cast<char*>(&_impl_.start_time_),
          reinterpret_cast<char*>(&other->_impl_.start_time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata InitMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[3]);
}
// ===================================================================

class PortExchange::_Internal {
 public:
  using HasBits = decltype(std::declval<PortExchange>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(PortExchange, _impl_._has_bits_);
  static void set_has_port_number(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

PortExchange::PortExchange(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.PortExchange)
}
PortExchange::PortExchange(const PortExchange& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.PortExchange)
}

inline void PortExchange::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.port_number_) { 0u }

  };
}

PortExchange::~PortExchange() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.PortExchange)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void PortExchange::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void PortExchange::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void PortExchange::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.PortExchange)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.port_number_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* PortExchange::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 port_number = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_port_number(&has_bits);
          _impl_.port_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* PortExchange::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.PortExchange)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 port_number = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_port_number(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.PortExchange)
  return target;
}

::size_t PortExchange::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.PortExchange)
  ::size_t total_size = 0;

  // required uint32 port_number = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_port_number());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData PortExchange::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    PortExchange::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*PortExchange::GetClassData() const { return &_class_data_; }


void PortExchange::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<PortExchange*>(&to_msg);
  auto& from = static_cast<const PortExchange&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.PortExchange)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_port_number(from._internal_port_number());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void PortExchange::CopyFrom(const PortExchange& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.PortExchange)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PortExchange::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void PortExchange::InternalSwap(PortExchange* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.port_number_, other->_impl_.port_number_);
}

::PROTOBUF_NAMESPACE_ID::Metadata PortExchange::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[4]);
}
// ===================================================================

class TimeMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<TimeMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(TimeMessage, _impl_._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

TimeMessage::TimeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.TimeMessage)
}
TimeMessage::TimeMessage(const TimeMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.TimeMessage)
}

inline void TimeMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_) { ::int64_t{0} }

  };
}

TimeMessage::~TimeMessage() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.TimeMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TimeMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void TimeMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void TimeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.TimeMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.time_ = ::int64_t{0};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* TimeMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* TimeMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.TimeMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.TimeMessage)
  return target;
}

::size_t TimeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.TimeMessage)
  ::size_t total_size = 0;

  // required int64 time = 1;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData TimeMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    TimeMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*TimeMessage::GetClassData() const { return &_class_data_; }


void TimeMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<TimeMessage*>(&to_msg);
  auto& from = static_cast<const TimeMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.TimeMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_internal_set_time(from._internal_time());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void TimeMessage::CopyFrom(const TimeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.TimeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void TimeMessage::InternalSwap(TimeMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);

  swap(_impl_.time_, other->_impl_.time_);
}

::PROTOBUF_NAMESPACE_ID::Metadata TimeMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[5]);
}
// ===================================================================

class ReceiveMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ReceiveMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ReceiveMessage, _impl_._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channel_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_rssi(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

ReceiveMessage::ReceiveMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.ReceiveMessage)
}
ReceiveMessage::ReceiveMessage(const ReceiveMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.ReceiveMessage)
}

inline void ReceiveMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_) { ::int64_t{0} }

    , decltype(_impl_.node_id_) { 0u }

    , decltype(_impl_.channel_id_) { 0 }

    , decltype(_impl_.message_id_) { 0u }

    , decltype(_impl_.rssi_) { 0 }

  };
}

ReceiveMessage::~ReceiveMessage() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.ReceiveMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ReceiveMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ReceiveMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ReceiveMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.ReceiveMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.rssi_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.rssi_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ReceiveMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::RadioChannel_IsValid(static_cast<int>(val)))) {
            _internal_set_channel_id(static_cast<::ClientServerChannelSpace::RadioChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 message_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_message_id(&has_bits);
          _impl_.message_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required float rssi = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 45)) {
          _Internal::set_has_rssi(&has_bits);
          _impl_.rssi_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ReceiveMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.ReceiveMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_time(), target);
  }

  // required uint32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_node_id(), target);
  }

  // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_channel_id(), target);
  }

  // required uint32 message_id = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_message_id(), target);
  }

  // required float rssi = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(
        5, this->_internal_rssi(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.ReceiveMessage)
  return target;
}

::size_t ReceiveMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.ReceiveMessage)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required int64 time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required uint32 node_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_node_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required uint32 message_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_message_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    // required float rssi = 5;
    total_size += 5;
  }

  return total_size;
}
::size_t ReceiveMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.ReceiveMessage)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int64 time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());

    // required uint32 node_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_node_id());

    // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_id());

    // required uint32 message_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_message_id());

    // required float rssi = 5;
    total_size += 5;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ReceiveMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ReceiveMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ReceiveMessage::GetClassData() const { return &_class_data_; }


void ReceiveMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ReceiveMessage*>(&to_msg);
  auto& from = static_cast<const ReceiveMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.ReceiveMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.message_id_ = from._impl_.message_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.rssi_ = from._impl_.rssi_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ReceiveMessage::CopyFrom(const ReceiveMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.ReceiveMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiveMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ReceiveMessage::InternalSwap(ReceiveMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ReceiveMessage, _impl_.rssi_)
      + sizeof(ReceiveMessage::_impl_.rssi_)
      - PROTOBUF_FIELD_OFFSET(ReceiveMessage, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ReceiveMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[6]);
}
// ===================================================================

class ConfigureRadioMessage_RadioConfiguration::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigureRadioMessage_RadioConfiguration>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConfigureRadioMessage_RadioConfiguration, _impl_._has_bits_);
  static void set_has_receiving_messages(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_subnet_address(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_transmission_power(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_radio_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_primary_radio_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_secondary_radio_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000005f) ^ 0x0000005f) != 0;
  }
};

ConfigureRadioMessage_RadioConfiguration::ConfigureRadioMessage_RadioConfiguration(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
}
ConfigureRadioMessage_RadioConfiguration::ConfigureRadioMessage_RadioConfiguration(const ConfigureRadioMessage_RadioConfiguration& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
}

inline void ConfigureRadioMessage_RadioConfiguration::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.receiving_messages_) { false }

    , decltype(_impl_.ip_address_) { 0u }

    , decltype(_impl_.transmission_power_) { 0 }

    , decltype(_impl_.subnet_address_) { 0u }

    , decltype(_impl_.primary_radio_channel_) { 0 }

    , decltype(_impl_.secondary_radio_channel_) { 0 }

    , decltype(_impl_.radio_mode_) { 1 }

  };
}

ConfigureRadioMessage_RadioConfiguration::~ConfigureRadioMessage_RadioConfiguration() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigureRadioMessage_RadioConfiguration::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void ConfigureRadioMessage_RadioConfiguration::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigureRadioMessage_RadioConfiguration::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    ::memset(&_impl_.receiving_messages_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.secondary_radio_channel_) -
        reinterpret_cast<char*>(&_impl_.receiving_messages_)) + sizeof(_impl_.secondary_radio_channel_));
    _impl_.radio_mode_ = 1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigureRadioMessage_RadioConfiguration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required bool receiving_messages = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_receiving_messages(&has_bits);
          _impl_.receiving_messages_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 ip_address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ip_address(&has_bits);
          _impl_.ip_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 subnet_address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_subnet_address(&has_bits);
          _impl_.subnet_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double transmission_power = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_transmission_power(&has_bits);
          _impl_.transmission_power_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration.RadioMode radio_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration_RadioMode_IsValid(static_cast<int>(val)))) {
            _internal_set_radio_mode(static_cast<::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration_RadioMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(5, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // required .ClientServerChannelSpace.RadioChannel primary_radio_channel = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 48)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::RadioChannel_IsValid(static_cast<int>(val)))) {
            _internal_set_primary_radio_channel(static_cast<::ClientServerChannelSpace::RadioChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .ClientServerChannelSpace.RadioChannel secondary_radio_channel = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 56)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::RadioChannel_IsValid(static_cast<int>(val)))) {
            _internal_set_secondary_radio_channel(static_cast<::ClientServerChannelSpace::RadioChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(7, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConfigureRadioMessage_RadioConfiguration::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required bool receiving_messages = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(
        1, this->_internal_receiving_messages(), target);
  }

  // required uint32 ip_address = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_ip_address(), target);
  }

  // required uint32 subnet_address = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_subnet_address(), target);
  }

  // required double transmission_power = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_transmission_power(), target);
  }

  // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration.RadioMode radio_mode = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        5, this->_internal_radio_mode(), target);
  }

  // required .ClientServerChannelSpace.RadioChannel primary_radio_channel = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        6, this->_internal_primary_radio_channel(), target);
  }

  // optional .ClientServerChannelSpace.RadioChannel secondary_radio_channel = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        7, this->_internal_secondary_radio_channel(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  return target;
}

::size_t ConfigureRadioMessage_RadioConfiguration::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required bool receiving_messages = 1;
    total_size += 2;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required uint32 ip_address = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double transmission_power = 4;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required uint32 subnet_address = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_subnet_address());
  }

  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    // required .ClientServerChannelSpace.RadioChannel primary_radio_channel = 6;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_primary_radio_channel());
  }

  if ((_impl_._has_bits_[0] & 0x00000040u) != 0) {
    // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration.RadioMode radio_mode = 5;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_radio_mode());
  }

  return total_size;
}
::size_t ConfigureRadioMessage_RadioConfiguration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000005f) ^ 0x0000005f) == 0) {  // All required fields are present.
    // required bool receiving_messages = 1;
    total_size += 2;

    // required uint32 ip_address = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());

    // required double transmission_power = 4;
    total_size += 9;

    // required uint32 subnet_address = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_subnet_address());

    // required .ClientServerChannelSpace.RadioChannel primary_radio_channel = 6;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_primary_radio_channel());

    // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration.RadioMode radio_mode = 5;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_radio_mode());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .ClientServerChannelSpace.RadioChannel secondary_radio_channel = 7;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000020u) {
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_secondary_radio_channel());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigureRadioMessage_RadioConfiguration::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigureRadioMessage_RadioConfiguration::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigureRadioMessage_RadioConfiguration::GetClassData() const { return &_class_data_; }


void ConfigureRadioMessage_RadioConfiguration::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigureRadioMessage_RadioConfiguration*>(&to_msg);
  auto& from = static_cast<const ConfigureRadioMessage_RadioConfiguration&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.receiving_messages_ = from._impl_.receiving_messages_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ip_address_ = from._impl_.ip_address_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.transmission_power_ = from._impl_.transmission_power_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.subnet_address_ = from._impl_.subnet_address_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.primary_radio_channel_ = from._impl_.primary_radio_channel_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.secondary_radio_channel_ = from._impl_.secondary_radio_channel_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radio_mode_ = from._impl_.radio_mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigureRadioMessage_RadioConfiguration::CopyFrom(const ConfigureRadioMessage_RadioConfiguration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureRadioMessage_RadioConfiguration::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void ConfigureRadioMessage_RadioConfiguration::InternalSwap(ConfigureRadioMessage_RadioConfiguration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureRadioMessage_RadioConfiguration, _impl_.radio_mode_)
      + sizeof(ConfigureRadioMessage_RadioConfiguration::_impl_.radio_mode_)
      - PROTOBUF_FIELD_OFFSET(ConfigureRadioMessage_RadioConfiguration, _impl_.receiving_messages_)>(
          reinterpret_cast<char*>(&_impl_.receiving_messages_),
          reinterpret_cast<char*>(&other->_impl_.receiving_messages_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigureRadioMessage_RadioConfiguration::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[7]);
}
// ===================================================================

class ConfigureRadioMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<ConfigureRadioMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(ConfigureRadioMessage, _impl_._has_bits_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_external_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_radio_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration& primary_radio_configuration(const ConfigureRadioMessage* msg);
  static void set_has_primary_radio_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration& secondary_radio_configuration(const ConfigureRadioMessage* msg);
  static void set_has_secondary_radio_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000003d) ^ 0x0000003d) != 0;
  }
};

const ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration&
ConfigureRadioMessage::_Internal::primary_radio_configuration(const ConfigureRadioMessage* msg) {
  return *msg->_impl_.primary_radio_configuration_;
}
const ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration&
ConfigureRadioMessage::_Internal::secondary_radio_configuration(const ConfigureRadioMessage* msg) {
  return *msg->_impl_.secondary_radio_configuration_;
}
ConfigureRadioMessage::ConfigureRadioMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.ConfigureRadioMessage)
}
ConfigureRadioMessage::ConfigureRadioMessage(const ConfigureRadioMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ConfigureRadioMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.primary_radio_configuration_){nullptr}
    , decltype(_impl_.secondary_radio_configuration_){nullptr}
    , decltype(_impl_.time_) {}

    , decltype(_impl_.message_id_) {}

    , decltype(_impl_.external_id_) {}

    , decltype(_impl_.radio_number_) {}
  };

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if ((from._impl_._has_bits_[0] & 0x00000001u) != 0) {
    _this->_impl_.primary_radio_configuration_ = new ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration(*from._impl_.primary_radio_configuration_);
  }
  if ((from._impl_._has_bits_[0] & 0x00000002u) != 0) {
    _this->_impl_.secondary_radio_configuration_ = new ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration(*from._impl_.secondary_radio_configuration_);
  }
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.radio_number_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.radio_number_));
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.ConfigureRadioMessage)
}

inline void ConfigureRadioMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.primary_radio_configuration_){nullptr}
    , decltype(_impl_.secondary_radio_configuration_){nullptr}
    , decltype(_impl_.time_) { ::int64_t{0} }

    , decltype(_impl_.message_id_) { 0u }

    , decltype(_impl_.external_id_) { 0u }

    , decltype(_impl_.radio_number_) { 0 }

  };
}

ConfigureRadioMessage::~ConfigureRadioMessage() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.ConfigureRadioMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ConfigureRadioMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.primary_radio_configuration_;
  if (this != internal_default_instance()) delete _impl_.secondary_radio_configuration_;
}

void ConfigureRadioMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ConfigureRadioMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.ConfigureRadioMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      ABSL_DCHECK(_impl_.primary_radio_configuration_ != nullptr);
      _impl_.primary_radio_configuration_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      ABSL_DCHECK(_impl_.secondary_radio_configuration_ != nullptr);
      _impl_.secondary_radio_configuration_->Clear();
    }
  }
  if (cached_has_bits & 0x0000003cu) {
    ::memset(&_impl_.time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.radio_number_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.radio_number_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ConfigureRadioMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 message_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_message_id(&has_bits);
          _impl_.message_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 external_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          _Internal::set_has_external_id(&has_bits);
          _impl_.external_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioNumber radio_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::ConfigureRadioMessage_RadioNumber_IsValid(static_cast<int>(val)))) {
            _internal_set_radio_number(static_cast<::ClientServerChannelSpace::ConfigureRadioMessage_RadioNumber>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration primary_radio_configuration = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_primary_radio_configuration(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // optional .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration secondary_radio_configuration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_secondary_radio_configuration(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* ConfigureRadioMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.ConfigureRadioMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 time = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_time(), target);
  }

  // required uint32 message_id = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_message_id(), target);
  }

  // required uint32 external_id = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        3, this->_internal_external_id(), target);
  }

  // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioNumber radio_number = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        4, this->_internal_radio_number(), target);
  }

  // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration primary_radio_configuration = 5;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::primary_radio_configuration(this),
        _Internal::primary_radio_configuration(this).GetCachedSize(), target, stream);
  }

  // optional .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration secondary_radio_configuration = 6;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::secondary_radio_configuration(this),
        _Internal::secondary_radio_configuration(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.ConfigureRadioMessage)
  return target;
}

::size_t ConfigureRadioMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.ConfigureRadioMessage)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration primary_radio_configuration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.primary_radio_configuration_);
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required int64 time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required uint32 message_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_message_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    // required uint32 external_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_external_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000020u) != 0) {
    // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioNumber radio_number = 4;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_radio_number());
  }

  return total_size;
}
::size_t ConfigureRadioMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.ConfigureRadioMessage)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000003d) ^ 0x0000003d) == 0) {  // All required fields are present.
    // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration primary_radio_configuration = 5;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.primary_radio_configuration_);

    // required int64 time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());

    // required uint32 message_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_message_id());

    // required uint32 external_id = 3;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_external_id());

    // required .ClientServerChannelSpace.ConfigureRadioMessage.RadioNumber radio_number = 4;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_radio_number());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .ClientServerChannelSpace.ConfigureRadioMessage.RadioConfiguration secondary_radio_configuration = 6;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.secondary_radio_configuration_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ConfigureRadioMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ConfigureRadioMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ConfigureRadioMessage::GetClassData() const { return &_class_data_; }


void ConfigureRadioMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ConfigureRadioMessage*>(&to_msg);
  auto& from = static_cast<const ConfigureRadioMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.ConfigureRadioMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_primary_radio_configuration()->::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration::MergeFrom(
          from._internal_primary_radio_configuration());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_secondary_radio_configuration()->::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration::MergeFrom(
          from._internal_secondary_radio_configuration());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.message_id_ = from._impl_.message_id_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.external_id_ = from._impl_.external_id_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.radio_number_ = from._impl_.radio_number_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ConfigureRadioMessage::CopyFrom(const ConfigureRadioMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.ConfigureRadioMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConfigureRadioMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    if (!_impl_.primary_radio_configuration_->IsInitialized()) return false;
  }
  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    if (!_impl_.secondary_radio_configuration_->IsInitialized()) return false;
  }
  return true;
}

void ConfigureRadioMessage::InternalSwap(ConfigureRadioMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ConfigureRadioMessage, _impl_.radio_number_)
      + sizeof(ConfigureRadioMessage::_impl_.radio_number_)
      - PROTOBUF_FIELD_OFFSET(ConfigureRadioMessage, _impl_.primary_radio_configuration_)>(
          reinterpret_cast<char*>(&_impl_.primary_radio_configuration_),
          reinterpret_cast<char*>(&other->_impl_.primary_radio_configuration_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ConfigureRadioMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[8]);
}
// ===================================================================

class SendMessageMessage_TopoAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<SendMessageMessage_TopoAddress>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SendMessageMessage_TopoAddress, _impl_._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ttl(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SendMessageMessage_TopoAddress::SendMessageMessage_TopoAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
}
SendMessageMessage_TopoAddress::SendMessageMessage_TopoAddress(const SendMessageMessage_TopoAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
}

inline void SendMessageMessage_TopoAddress::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ip_address_) { 0u }

    , decltype(_impl_.ttl_) { 0u }

  };
}

SendMessageMessage_TopoAddress::~SendMessageMessage_TopoAddress() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendMessageMessage_TopoAddress::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SendMessageMessage_TopoAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SendMessageMessage_TopoAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.ip_address_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ttl_) -
        reinterpret_cast<char*>(&_impl_.ip_address_)) + sizeof(_impl_.ttl_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SendMessageMessage_TopoAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ip_address(&has_bits);
          _impl_.ip_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 ttl = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_ttl(&has_bits);
          _impl_.ttl_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SendMessageMessage_TopoAddress::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ip_address = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_ip_address(), target);
  }

  // required uint32 ttl = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_ttl(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  return target;
}

::size_t SendMessageMessage_TopoAddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required uint32 ip_address = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required uint32 ttl = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ttl());
  }

  return total_size;
}
::size_t SendMessageMessage_TopoAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 ip_address = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());

    // required uint32 ttl = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ttl());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SendMessageMessage_TopoAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SendMessageMessage_TopoAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SendMessageMessage_TopoAddress::GetClassData() const { return &_class_data_; }


void SendMessageMessage_TopoAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SendMessageMessage_TopoAddress*>(&to_msg);
  auto& from = static_cast<const SendMessageMessage_TopoAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.ip_address_ = from._impl_.ip_address_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ttl_ = from._impl_.ttl_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SendMessageMessage_TopoAddress::CopyFrom(const SendMessageMessage_TopoAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.SendMessageMessage.TopoAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendMessageMessage_TopoAddress::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SendMessageMessage_TopoAddress::InternalSwap(SendMessageMessage_TopoAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SendMessageMessage_TopoAddress, _impl_.ttl_)
      + sizeof(SendMessageMessage_TopoAddress::_impl_.ttl_)
      - PROTOBUF_FIELD_OFFSET(SendMessageMessage_TopoAddress, _impl_.ip_address_)>(
          reinterpret_cast<char*>(&_impl_.ip_address_),
          reinterpret_cast<char*>(&other->_impl_.ip_address_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SendMessageMessage_TopoAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[9]);
}
// ===================================================================

class SendMessageMessage_GeoRectangleAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<SendMessageMessage_GeoRectangleAddress>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SendMessageMessage_GeoRectangleAddress, _impl_._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_a_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_a_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_b_x(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_b_y(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

SendMessageMessage_GeoRectangleAddress::SendMessageMessage_GeoRectangleAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
}
SendMessageMessage_GeoRectangleAddress::SendMessageMessage_GeoRectangleAddress(const SendMessageMessage_GeoRectangleAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
}

inline void SendMessageMessage_GeoRectangleAddress::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.a_x_) { 0 }

    , decltype(_impl_.a_y_) { 0 }

    , decltype(_impl_.b_x_) { 0 }

    , decltype(_impl_.b_y_) { 0 }

    , decltype(_impl_.ip_address_) { 0u }

  };
}

SendMessageMessage_GeoRectangleAddress::~SendMessageMessage_GeoRectangleAddress() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendMessageMessage_GeoRectangleAddress::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SendMessageMessage_GeoRectangleAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SendMessageMessage_GeoRectangleAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.a_x_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ip_address_) -
        reinterpret_cast<char*>(&_impl_.a_x_)) + sizeof(_impl_.ip_address_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SendMessageMessage_GeoRectangleAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ip_address(&has_bits);
          _impl_.ip_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double a_X = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_a_x(&has_bits);
          _impl_.a_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double a_Y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_a_y(&has_bits);
          _impl_.a_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double b_X = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_b_x(&has_bits);
          _impl_.b_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double b_Y = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 41)) {
          _Internal::set_has_b_y(&has_bits);
          _impl_.b_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SendMessageMessage_GeoRectangleAddress::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ip_address = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_ip_address(), target);
  }

  // required double a_X = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_a_x(), target);
  }

  // required double a_Y = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_a_y(), target);
  }

  // required double b_X = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_b_x(), target);
  }

  // required double b_Y = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        5, this->_internal_b_y(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  return target;
}

::size_t SendMessageMessage_GeoRectangleAddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double a_X = 2;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double a_Y = 3;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double b_X = 4;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required double b_Y = 5;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    // required uint32 ip_address = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());
  }

  return total_size;
}
::size_t SendMessageMessage_GeoRectangleAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required double a_X = 2;
    total_size += 9;

    // required double a_Y = 3;
    total_size += 9;

    // required double b_X = 4;
    total_size += 9;

    // required double b_Y = 5;
    total_size += 9;

    // required uint32 ip_address = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SendMessageMessage_GeoRectangleAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SendMessageMessage_GeoRectangleAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SendMessageMessage_GeoRectangleAddress::GetClassData() const { return &_class_data_; }


void SendMessageMessage_GeoRectangleAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SendMessageMessage_GeoRectangleAddress*>(&to_msg);
  auto& from = static_cast<const SendMessageMessage_GeoRectangleAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.a_x_ = from._impl_.a_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.a_y_ = from._impl_.a_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.b_x_ = from._impl_.b_x_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.b_y_ = from._impl_.b_y_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.ip_address_ = from._impl_.ip_address_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SendMessageMessage_GeoRectangleAddress::CopyFrom(const SendMessageMessage_GeoRectangleAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendMessageMessage_GeoRectangleAddress::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SendMessageMessage_GeoRectangleAddress::InternalSwap(SendMessageMessage_GeoRectangleAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SendMessageMessage_GeoRectangleAddress, _impl_.ip_address_)
      + sizeof(SendMessageMessage_GeoRectangleAddress::_impl_.ip_address_)
      - PROTOBUF_FIELD_OFFSET(SendMessageMessage_GeoRectangleAddress, _impl_.a_x_)>(
          reinterpret_cast<char*>(&_impl_.a_x_),
          reinterpret_cast<char*>(&other->_impl_.a_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SendMessageMessage_GeoRectangleAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[10]);
}
// ===================================================================

class SendMessageMessage_GeoCircleAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<SendMessageMessage_GeoCircleAddress>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SendMessageMessage_GeoCircleAddress, _impl_._has_bits_);
  static void set_has_ip_address(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_center_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_center_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

SendMessageMessage_GeoCircleAddress::SendMessageMessage_GeoCircleAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
}
SendMessageMessage_GeoCircleAddress::SendMessageMessage_GeoCircleAddress(const SendMessageMessage_GeoCircleAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(), _impl_(from._impl_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(
      from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
}

inline void SendMessageMessage_GeoCircleAddress::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.center_x_) { 0 }

    , decltype(_impl_.center_y_) { 0 }

    , decltype(_impl_.radius_) { 0 }

    , decltype(_impl_.ip_address_) { 0u }

  };
}

SendMessageMessage_GeoCircleAddress::~SendMessageMessage_GeoCircleAddress() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendMessageMessage_GeoCircleAddress::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
}

void SendMessageMessage_GeoCircleAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SendMessageMessage_GeoCircleAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.center_x_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.ip_address_) -
        reinterpret_cast<char*>(&_impl_.center_x_)) + sizeof(_impl_.ip_address_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SendMessageMessage_GeoCircleAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required uint32 ip_address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_ip_address(&has_bits);
          _impl_.ip_address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double center_X = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 17)) {
          _Internal::set_has_center_x(&has_bits);
          _impl_.center_x_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double center_Y = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 25)) {
          _Internal::set_has_center_y(&has_bits);
          _impl_.center_y_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      // required double radius = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 33)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SendMessageMessage_GeoCircleAddress::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required uint32 ip_address = 1;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        1, this->_internal_ip_address(), target);
  }

  // required double center_X = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        2, this->_internal_center_x(), target);
  }

  // required double center_Y = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        3, this->_internal_center_y(), target);
  }

  // required double radius = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(
        4, this->_internal_radius(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  return target;
}

::size_t SendMessageMessage_GeoCircleAddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required double center_X = 2;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required double center_Y = 3;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required double radius = 4;
    total_size += 9;
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required uint32 ip_address = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());
  }

  return total_size;
}
::size_t SendMessageMessage_GeoCircleAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required double center_X = 2;
    total_size += 9;

    // required double center_Y = 3;
    total_size += 9;

    // required double radius = 4;
    total_size += 9;

    // required uint32 ip_address = 1;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_ip_address());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SendMessageMessage_GeoCircleAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SendMessageMessage_GeoCircleAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SendMessageMessage_GeoCircleAddress::GetClassData() const { return &_class_data_; }


void SendMessageMessage_GeoCircleAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SendMessageMessage_GeoCircleAddress*>(&to_msg);
  auto& from = static_cast<const SendMessageMessage_GeoCircleAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.center_x_ = from._impl_.center_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.center_y_ = from._impl_.center_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.ip_address_ = from._impl_.ip_address_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SendMessageMessage_GeoCircleAddress::CopyFrom(const SendMessageMessage_GeoCircleAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendMessageMessage_GeoCircleAddress::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SendMessageMessage_GeoCircleAddress::InternalSwap(SendMessageMessage_GeoCircleAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SendMessageMessage_GeoCircleAddress, _impl_.ip_address_)
      + sizeof(SendMessageMessage_GeoCircleAddress::_impl_.ip_address_)
      - PROTOBUF_FIELD_OFFSET(SendMessageMessage_GeoCircleAddress, _impl_.center_x_)>(
          reinterpret_cast<char*>(&_impl_.center_x_),
          reinterpret_cast<char*>(&other->_impl_.center_x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SendMessageMessage_GeoCircleAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[11]);
}
// ===================================================================

class SendMessageMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<SendMessageMessage>()._impl_._has_bits_);
  static constexpr ::int32_t kHasBitsOffset =
    8 * PROTOBUF_FIELD_OFFSET(SendMessageMessage, _impl_._has_bits_);
  static constexpr ::int32_t kOneofCaseOffset =
    PROTOBUF_FIELD_OFFSET(::ClientServerChannelSpace::SendMessageMessage, _impl_._oneof_case_);
  static void set_has_time(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_node_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_channel_id(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_message_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::ClientServerChannelSpace::SendMessageMessage_TopoAddress& topo_address(const SendMessageMessage* msg);
  static const ::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress& rectangle_address(const SendMessageMessage* msg);
  static const ::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress& circle_address(const SendMessageMessage* msg);
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000001f) ^ 0x0000001f) != 0;
  }
};

const ::ClientServerChannelSpace::SendMessageMessage_TopoAddress&
SendMessageMessage::_Internal::topo_address(const SendMessageMessage* msg) {
  return *msg->_impl_.address_.topo_address_;
}
const ::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress&
SendMessageMessage::_Internal::rectangle_address(const SendMessageMessage* msg) {
  return *msg->_impl_.address_.rectangle_address_;
}
const ::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress&
SendMessageMessage::_Internal::circle_address(const SendMessageMessage* msg) {
  return *msg->_impl_.address_.circle_address_;
}
void SendMessageMessage::set_allocated_topo_address(::ClientServerChannelSpace::SendMessageMessage_TopoAddress* topo_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_address();
  if (topo_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(topo_address);
    if (message_arena != submessage_arena) {
      topo_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, topo_address, submessage_arena);
    }
    set_has_topo_address();
    _impl_.address_.topo_address_ = topo_address;
  }
  // @@protoc_insertion_point(field_set_allocated:ClientServerChannelSpace.SendMessageMessage.topo_address)
}
void SendMessageMessage::set_allocated_rectangle_address(::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress* rectangle_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_address();
  if (rectangle_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(rectangle_address);
    if (message_arena != submessage_arena) {
      rectangle_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, rectangle_address, submessage_arena);
    }
    set_has_rectangle_address();
    _impl_.address_.rectangle_address_ = rectangle_address;
  }
  // @@protoc_insertion_point(field_set_allocated:ClientServerChannelSpace.SendMessageMessage.rectangle_address)
}
void SendMessageMessage::set_allocated_circle_address(::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress* circle_address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_address();
  if (circle_address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(circle_address);
    if (message_arena != submessage_arena) {
      circle_address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, circle_address, submessage_arena);
    }
    set_has_circle_address();
    _impl_.address_.circle_address_ = circle_address;
  }
  // @@protoc_insertion_point(field_set_allocated:ClientServerChannelSpace.SendMessageMessage.circle_address)
}
SendMessageMessage::SendMessageMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor(arena);
  // @@protoc_insertion_point(arena_constructor:ClientServerChannelSpace.SendMessageMessage)
}
SendMessageMessage::SendMessageMessage(const SendMessageMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SendMessageMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_) {}

    , decltype(_impl_.node_id_) {}

    , decltype(_impl_.channel_id_) {}

    , decltype(_impl_.length_) {}

    , decltype(_impl_.message_id_) {}

    , decltype(_impl_.address_){}
    , /*decltype(_impl_._oneof_case_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.time_, &from._impl_.time_,
    static_cast<::size_t>(reinterpret_cast<char*>(&_impl_.message_id_) -
    reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.message_id_));
  clear_has_address();
  switch (from.address_case()) {
    case kTopoAddress: {
      _this->_internal_mutable_topo_address()->::ClientServerChannelSpace::SendMessageMessage_TopoAddress::MergeFrom(
          from._internal_topo_address());
      break;
    }
    case kRectangleAddress: {
      _this->_internal_mutable_rectangle_address()->::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress::MergeFrom(
          from._internal_rectangle_address());
      break;
    }
    case kCircleAddress: {
      _this->_internal_mutable_circle_address()->::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress::MergeFrom(
          from._internal_circle_address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:ClientServerChannelSpace.SendMessageMessage)
}

inline void SendMessageMessage::SharedCtor(::_pb::Arena* arena) {
  (void)arena;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.time_) { ::int64_t{0} }

    , decltype(_impl_.node_id_) { 0u }

    , decltype(_impl_.channel_id_) { 0 }

    , decltype(_impl_.length_) { ::uint64_t{0u} }

    , decltype(_impl_.message_id_) { 0u }

    , decltype(_impl_.address_){}
    , /*decltype(_impl_._oneof_case_)*/{}
  };
  clear_has_address();
}

SendMessageMessage::~SendMessageMessage() {
  // @@protoc_insertion_point(destructor:ClientServerChannelSpace.SendMessageMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SendMessageMessage::SharedDtor() {
  ABSL_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_address()) {
    clear_address();
  }
}

void SendMessageMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SendMessageMessage::clear_address() {
// @@protoc_insertion_point(one_of_clear_start:ClientServerChannelSpace.SendMessageMessage)
  switch (address_case()) {
    case kTopoAddress: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.address_.topo_address_;
      }
      break;
    }
    case kRectangleAddress: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.address_.rectangle_address_;
      }
      break;
    }
    case kCircleAddress: {
      if (GetArenaForAllocation() == nullptr) {
        delete _impl_.address_.circle_address_;
      }
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _impl_._oneof_case_[0] = ADDRESS_NOT_SET;
}


void SendMessageMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:ClientServerChannelSpace.SendMessageMessage)
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.time_, 0, static_cast<::size_t>(
        reinterpret_cast<char*>(&_impl_.message_id_) -
        reinterpret_cast<char*>(&_impl_.time_)) + sizeof(_impl_.message_id_));
  }
  clear_address();
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SendMessageMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int64 time = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 8)) {
          _Internal::set_has_time(&has_bits);
          _impl_.time_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 node_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 16)) {
          _Internal::set_has_node_id(&has_bits);
          _impl_.node_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 24)) {
          ::int32_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ClientServerChannelSpace::RadioChannel_IsValid(static_cast<int>(val)))) {
            _internal_set_channel_id(static_cast<::ClientServerChannelSpace::RadioChannel>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint32 message_id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 32)) {
          _Internal::set_has_message_id(&has_bits);
          _impl_.message_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // required uint64 length = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 40)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .ClientServerChannelSpace.SendMessageMessage.TopoAddress topo_address = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_topo_address(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress rectangle_address = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_rectangle_address(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      // .ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress circle_address = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_circle_address(), ptr);
          CHK_(ptr);
        } else {
          goto handle_unusual;
        }
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

::uint8_t* SendMessageMessage::_InternalSerialize(
    ::uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ClientServerChannelSpace.SendMessageMessage)
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int64 time = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(
        1, this->_internal_time(), target);
  }

  // required uint32 node_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        2, this->_internal_node_id(), target);
  }

  // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
        3, this->_internal_channel_id(), target);
  }

  // required uint32 message_id = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(
        4, this->_internal_message_id(), target);
  }

  // required uint64 length = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(
        5, this->_internal_length(), target);
  }

  switch (address_case()) {
    case kTopoAddress: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, _Internal::topo_address(this),
          _Internal::topo_address(this).GetCachedSize(), target, stream);
      break;
    }
    case kRectangleAddress: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, _Internal::rectangle_address(this),
          _Internal::rectangle_address(this).GetCachedSize(), target, stream);
      break;
    }
    case kCircleAddress: {
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(8, _Internal::circle_address(this),
          _Internal::circle_address(this).GetCachedSize(), target, stream);
      break;
    }
    default: ;
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ClientServerChannelSpace.SendMessageMessage)
  return target;
}

::size_t SendMessageMessage::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:ClientServerChannelSpace.SendMessageMessage)
  ::size_t total_size = 0;

  if ((_impl_._has_bits_[0] & 0x00000001u) != 0) {
    // required int64 time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());
  }

  if ((_impl_._has_bits_[0] & 0x00000002u) != 0) {
    // required uint32 node_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_node_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000004u) != 0) {
    // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_id());
  }

  if ((_impl_._has_bits_[0] & 0x00000008u) != 0) {
    // required uint64 length = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_length());
  }

  if ((_impl_._has_bits_[0] & 0x00000010u) != 0) {
    // required uint32 message_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_message_id());
  }

  return total_size;
}
::size_t SendMessageMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ClientServerChannelSpace.SendMessageMessage)
  ::size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x0000001f) ^ 0x0000001f) == 0) {  // All required fields are present.
    // required int64 time = 1;
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(
        this->_internal_time());

    // required uint32 node_id = 2;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_node_id());

    // required .ClientServerChannelSpace.RadioChannel channel_id = 3;
    total_size += 1 +
                  ::_pbi::WireFormatLite::EnumSize(this->_internal_channel_id());

    // required uint64 length = 5;
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(
        this->_internal_length());

    // required uint32 message_id = 4;
    total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(
        this->_internal_message_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (address_case()) {
    // .ClientServerChannelSpace.SendMessageMessage.TopoAddress topo_address = 6;
    case kTopoAddress: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.address_.topo_address_);
      break;
    }
    // .ClientServerChannelSpace.SendMessageMessage.GeoRectangleAddress rectangle_address = 7;
    case kRectangleAddress: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.address_.rectangle_address_);
      break;
    }
    // .ClientServerChannelSpace.SendMessageMessage.GeoCircleAddress circle_address = 8;
    case kCircleAddress: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.address_.circle_address_);
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SendMessageMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SendMessageMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SendMessageMessage::GetClassData() const { return &_class_data_; }


void SendMessageMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SendMessageMessage*>(&to_msg);
  auto& from = static_cast<const SendMessageMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ClientServerChannelSpace.SendMessageMessage)
  ABSL_DCHECK_NE(&from, _this);
  ::uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.time_ = from._impl_.time_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.node_id_ = from._impl_.node_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.channel_id_ = from._impl_.channel_id_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.message_id_ = from._impl_.message_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  switch (from.address_case()) {
    case kTopoAddress: {
      _this->_internal_mutable_topo_address()->::ClientServerChannelSpace::SendMessageMessage_TopoAddress::MergeFrom(
          from._internal_topo_address());
      break;
    }
    case kRectangleAddress: {
      _this->_internal_mutable_rectangle_address()->::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress::MergeFrom(
          from._internal_rectangle_address());
      break;
    }
    case kCircleAddress: {
      _this->_internal_mutable_circle_address()->::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress::MergeFrom(
          from._internal_circle_address());
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SendMessageMessage::CopyFrom(const SendMessageMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ClientServerChannelSpace.SendMessageMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SendMessageMessage::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  switch (address_case()) {
    case kTopoAddress: {
      if (address_case() == kTopoAddress) {
        if (!_impl_.address_.topo_address_->IsInitialized()) return false;
      }
      break;
    }
    case kRectangleAddress: {
      if (address_case() == kRectangleAddress) {
        if (!_impl_.address_.rectangle_address_->IsInitialized()) return false;
      }
      break;
    }
    case kCircleAddress: {
      if (address_case() == kCircleAddress) {
        if (!_impl_.address_.circle_address_->IsInitialized()) return false;
      }
      break;
    }
    case ADDRESS_NOT_SET: {
      break;
    }
  }
  return true;
}

void SendMessageMessage::InternalSwap(SendMessageMessage* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SendMessageMessage, _impl_.message_id_)
      + sizeof(SendMessageMessage::_impl_.message_id_)
      - PROTOBUF_FIELD_OFFSET(SendMessageMessage, _impl_.time_)>(
          reinterpret_cast<char*>(&_impl_.time_),
          reinterpret_cast<char*>(&other->_impl_.time_));
  swap(_impl_.address_, other->_impl_.address_);
  swap(_impl_._oneof_case_[0], other->_impl_._oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata SendMessageMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_ClientServerChannelMessages_2eproto_getter, &descriptor_table_ClientServerChannelMessages_2eproto_once,
      file_level_metadata_ClientServerChannelMessages_2eproto[12]);
}
// @@protoc_insertion_point(namespace_scope)
}  // namespace ClientServerChannelSpace
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::CommandMessage*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::CommandMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::CommandMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::UpdateNode_NodeData*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::UpdateNode_NodeData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::UpdateNode_NodeData >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::UpdateNode*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::UpdateNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::UpdateNode >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::InitMessage*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::InitMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::InitMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::PortExchange*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::PortExchange >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::PortExchange >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::TimeMessage*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::TimeMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::TimeMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::ReceiveMessage*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::ReceiveMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::ReceiveMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::ConfigureRadioMessage_RadioConfiguration >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::ConfigureRadioMessage*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::ConfigureRadioMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::ConfigureRadioMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::SendMessageMessage_TopoAddress*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::SendMessageMessage_TopoAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::SendMessageMessage_TopoAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::SendMessageMessage_GeoRectangleAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::SendMessageMessage_GeoCircleAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::ClientServerChannelSpace::SendMessageMessage*
Arena::CreateMaybeMessage< ::ClientServerChannelSpace::SendMessageMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ClientServerChannelSpace::SendMessageMessage >(arena);
}
PROTOBUF_NAMESPACE_CLOSE
// @@protoc_insertion_point(global_scope)
#include "google/protobuf/port_undef.inc"
